# Fetch API
## 정의
- 네트워크 통신을 포함한 리소스 취득을 위한 인터페이스가 정의되어있는 모음.
- resource : DB에 저장되어있는 값들을 의미.
- CRUD
  1. C : Create - 데이터 생성
  2. R : Read - DB에 저장되어있는 데이터를 읽어오는 것
  3. U : Update - 데이터 수정
  4. D : Delete - 데이터 삭제

- localStorage에 todo / shopping item을 추가하고 읽어오고 삭제까지 해봤습니다.

이번 수업 때는 jsonplaceholder를 활용하여 CRUD를 구현해볼겁니다 -> Fetch API를 학습

https://jsonplaceholder.typicode.com
을 기준으로
1. /posts
2. /comments
3. /albums
4. /photos
5. /users
6. /todos
등을 통해 임의의 구현되어있는 JSON 데이터를 활용하여 저희의 프론트엔드에 표현하는 것이 가능합니다.

## Promise
자료형의 일종으로 추후 설명.

## Fetch API의 CRUD 별 사용 방법
```html
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Fetch API</title>
</head>
<body bgcolor="5f5f5f">
  <h1>01_fetchapi.html</h1>
  <script>
    // 형식에 주목해두겠습니다.
    // Get / Read : 읽어오기 / id가 1인 데이터 조회
    fetch("https://jsonplaceholder.typicode.com/posts/1")
    .then(response => response.json())
    .then((json) => console.log(json));
    // Post / Create : 데이터 생성
    fetch("https://jsonplaceholder.typicode.com/posts", {
      method: "POST",   // http request 요청 방법
      body: JSON.stringify({
        title: 'foo',
        body: 'bar',
        userId: 1,
      }),
      headers: {
        "content-type" : "application/json; charset=UTF-8",
      },
    })
    .then(response => response.json())
    .then(json => console.log(json));

    // Put / Update : 데이터 수정
    fetch("https://jsonplaceholder.typicode.com/posts/1", {
      method: 'PUT',
      body: JSON.stringify({
        id: 1,
        title: '이거 다음에는 Promise 타입 학습',
        body: '그거 하면 아마도 자습 시간 일 것 같습니다',
        userId: 1,
      }),
      headers: {
        'Content-type': 'application/json; charset=UTF-8',
      }
    })
    .then(response => response.json())
    .then(json => console.log(json));

    // Delete - 데이터 삭제
    fetch("https://jsonplaceholder.typicode.com/posts", {
      method: "DELETE",
    });
    // 데이터가 삭제 됐는지 확인할 수가 없기 때문에 Read를 새로 해야 합니다.
    fetch("https://jsonplaceholder.typicode.com/posts/1")
    .then(response => response.json())
    .then((json) => console.log(json));
    // 그러니까 삭제 후에는 todolist 기준으로 renderTodo를 새로 해야겠네요.
    // C / R / U / D 뒤에는 -> 새로 R을 해야한다고 알고 있겠습니다.
  </script>
</body>
</html>
```
- 추후 axios 라이브러리 도입하게 되면 좀 더 간단한 방법으로 코드를 작성할 수 있습니다.
# Promise & Asysnc/Await
## Promise
- JavaScript 상에서 '비동기처리'에 사용되는 '객체'. 비동기 처리란 특정 코드의 실행이 완료될 때까지 기다리지 않고 다음 코드를 실행할 수 있도록 하는 방식을 의미합니다.
- 원래 웹은 요청(request)에 대한 반응(response)이 _순차적으로 이루어지고_ , 먼저 실행된 코드가 완료되어야 다음 코드를 실행하는 순서를 가지고 있었는데, 개선 이후에 요청을 보낸 후 요청에 대한 응답이 돌아오는 것과 관계 없이 다음 코드를 실행시킬 수 있게 되었습니다.

- Promise는 JS에서 브라우저에 제공하는 비동기 함수인 Web APIs를 실행할 때 실행한 코드가 완료될 때까지 대기하지 않고 바로 다음 코드를 실행할 수 있도록 해주고, 비동기 함수의 실행이 완료되면 .then() 함수를 통해 그 결과에 대한 코드를 실행할 수 있게 해줍니다.

## Async / Await
- Promise와 동일한 목적으로 사용합니다. Async 비동기 실행을 의미하고, Await은 비동기 코드를 실행하는 데 결과가 올 때까지 기다렸다가 쓴다는 의미입니다. 각각 fetch()와 .then()에 매칭되기는 합니다.

02_asyncawait.js
```js
// 02_asyncawait.js

// fetch() / async 의 코드상 비교 관련 예시
function myFunction() {
  fetch("https://jsonplaceholder.typicode.com/posts/1")
  .then(response => response.json())
  .then(json => console.log(json))
}
myFunction();
// 이상의 예시는 GET 요청을 해서 서버로부터 응답이 오면 콘솔에 찍는 함수입니다

/**
 * 그런데 서버로 요청을 보내고 응담을 보낸 후에 응답받은 결과를 바탕으로 다시 서버로 요청을 보낸다고 가정해보겠습니다.
 */

function myFunction2() {
  fetch("https://jsonplaceholder.typicode.com/posts/1")
  .then(response => response.json())
  .then(json => {
    console.log(json)
  fetch("https://jsonplaceholder.typicode.com/posts/1", {
    method: "PUT",
    body: JSON.stringify({
      id: 1,
      title: '이제 슬슬 무슨 말하는지 모르겟다',
      body: '그냥 한 숨 잤으면 좋겠다',
      userId: 1,
    }),
    headers: {
      'content-type': 'application/json; charset=UTF-8',
    },
  })
  .then(response => response.json())
  .then(json => console.log(json));
  })
}

myFunction2();
/**
 * 이상의 코드는 결과적으로 GET 요청 이후에 결과값을 가지고 PUT요청을 새로한 후에 PUT의 결과를 확인할 수 있도록 GET 요청을 다시 날린 형태라고 볼 수 있습니다. 가독성이 떨어집니다.
 * 
 * 하지만 async / await 을 사용하면 좀 더 간결하게 쓸 수 있습니다.
 */

async function myFunction3() {
  const res1 = await fetch("https://jsonplaceholder.typicode.com/posts/1");
  const res1Json = await res1.json();
  console.log(res1Json);
  // 이상의 GET 요청 부분에 해당합니다. async / await을 빼면 일반적인 JavaScript처럼 함수 실행하고 결과값을 변수에 담는 것처럼 보입니다.
  // 이런 형식을 보고 비동기적 코드를 동기적인 방식으로 작성한다고 표현합니다.

  const res2 = await fetch("https://jsonplaceholder.typicode.com/posts/2", {
    method: 'PUT',
    body: JSON.stringify({
      id: 2,
      title: '아 공부가 어쩌고',
      body: '계속하고 싶다 진짜로',
      userId: 1,
    }),
    headers: {
      'content-type': 'application/json; charset=UTF-8',
    },
  });
  const res2Json = await res2.json();
  console.log(res2Json);
}
myFunction3();
```

# DOM 이벤트
- DOM(Document Object Model) -> document.write()
- 웹 페이지를 이용하면 웹 화면과 사용자 사이에서 많은 상호작용이 있습니다. 버튼 클릭, 마우스 스크롤, 검색 키워드를 입력하는 등의 행동이 해당됩니다. 사용자가 웹 페이지를 이용하면서 행하는 행위를 event라고 합니다.

1. click 이벤트 : onclick
사용자가 웹 페이지 내에서 마우스 왼쪽 버튼 클릭을 할 때 발생하는 이벤트. 웹 화면에서 일어나는 모든 클릭이벤트를 감시할 필요는 없지만 '검색', '저장' 처럼 사용자가 클릭을 하고 나면 연관된 기느을 처리해야 하는 클릭 이벤트에 대해서는 JS에서 함수를 정의하여 확인할 필요가 있습니다.(addTodo()를 예로 들 수 있습니다)

- button 태그 요소에 클릭 이벤트가 일어나는지를 감시하고 클릭 이벤트가 일어나는 순간 특정 함수를 실행시키려면 button 태그에 onclick 속성을 사용해서 처리할 수 있습니다(근데 우리는 button 태그에 id값 넣고 거기에서 클릭 이벤트를 addEventListner()를 통해서 처리했습니다).

ch11_events -> 01_events.html
```html
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body bgcolor="5f5f5f">
  <button onclick="myFunction1();">클릭</button>
  <button id="btn1">클릭</button>
  <button id="btn2">클릭</button>
  <button id="btn3">클릭</button>
  <script>
    function myFunction1() {
      console.log('onclick 이벤트 설정');
    }
    function myFunction2() {
      console.log('이벤트 리스너 사용');
    }
    document.getElementById('btn1').addEventListener('click', myFunction2);
    document.getElementById('btn2').addEventListener('click', function() {
      console.log('콜백 함수 실행');
    })
    document.getElementById('btn3').addEventListener('click', () => console.log('화살표 함수 실행'));
  </script>
</body>
</html>
```

2. change 이벤트 : onchange
- 값이 변경되었을 때 발생하는 이벤트입니다. 대표적으로 change 이벤트가 발생하는 DOM요소는 `<select>, <input type="checkbox">, <input type="radio">` 태그입니다.
select는 여러 개의 옵션에서 하나 이상의 옵션을 선택할 때 사용하는 DOM 요소로, 사용자가 옵션을 바꿀 때 마다 웹에서는 change 이벤트가 발생되고, JS에서 이 이벤트를 감시하며 특정 함수를 실행하는 방식을 택합니다. onchange 속성을 활용합니다.
```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body bgcolor="5f5f5f">
  <select id="select1" onchange="doChange();">
    <option value="KO">한국</option>
    <option value="CN">중국</option>
    <option value="JP">일본</option>
  </select>
  <script>
    function doChange() {
      let selectedValue = document.getElementById('select1').value;
      console.log(selectedValue);
    }
  </script>
</body>
</html>
```

3. key 이벤트(onkeydown, onkeypress, onkeyup)
- key 이벤트는 사용자가 입력창에서 키보드를 입력할 때 발생합니다. 사용자가 키를 입력하면 keydown, keypress, keyup 순으로 이벤트가 발생합니다. 예제를 통해 확인하겠습니다.

03_keyevent.html
```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body bgcolor="5f5f5f">
  <input 
    type="text"
    onkeypress="myFunction(event)"
    onkeydown="myFunction(event)"
    onkeyup="myFunction(event)"
  >
  <script>
    function myFunction(e) {
      console.log(e.type);  // 이벤트 이름 출력
      console.log(e.target);  // 이벤트를 발생시킨 DOM 요소
      console.log(e.target.value);  // 이벤트 입력 시점에 입력된 값이 어떻게 변하는지 출력 -> e.target.value는 input 태그에서 그냥 필수적이라고 보셔도 됩니다.
    }
  </script>
</body>
</html>
```
이상의 코드에서 input type text 라면 e.target.value는 꼭꼭꼭 기억할 것.
input 창에서 입력 받은 데이터가 DB에 있는 id와 일치하는지, 비밀번호와 일치하는지 체크하게 되겠죠.